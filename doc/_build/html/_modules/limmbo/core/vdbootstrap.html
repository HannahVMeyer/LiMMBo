

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>limmbo.core.vdbootstrap &mdash; LiMMBo b documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="LiMMBo b documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> LiMMBo
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input.html">Data input</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vd.html">Variance decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gwas.html">Association analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cmd.html">Command-line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Additional functions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">LiMMBo</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>limmbo.core.vdbootstrap</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for limmbo.core.vdbootstrap</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">limmbo.utils.utils</span> <span class="k">import</span> <span class="n">verboseprint</span>
<span class="kn">from</span> <span class="nn">limmbo.utils.utils</span> <span class="k">import</span> <span class="n">nans</span>
<span class="kn">from</span> <span class="nn">limmbo.utils.utils</span> <span class="k">import</span> <span class="n">regularize</span>
<span class="kn">from</span> <span class="nn">limmbo.utils.utils</span> <span class="k">import</span> <span class="n">inflate_matrix</span>

<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">fmin_l_bfgs_b</span> <span class="k">as</span> <span class="n">opt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">bottleneck</span> <span class="k">as</span> <span class="nn">bn</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">cPickle</span>

<span class="kn">import</span> <span class="nn">limix_legacy</span> <span class="k">as</span> <span class="nn">dlimix</span>
<span class="kn">import</span> <span class="nn">limix.mtset</span>

<span class="kn">from</span> <span class="nn">limix_core.covar</span> <span class="k">import</span> <span class="n">FreeFormCov</span>
<span class="kn">import</span> <span class="nn">pp</span>

<span class="k">class</span> <span class="nc">DataMismatch</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when dimensions of sample/ID names do not match dimension of</span>
<span class="sd">    corresponding data&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="LiMMBo"><a class="viewcode-back" href="../../../vd.html#limmbo.core.vdbootstrap.LiMMBo">[docs]</a><span class="k">class</span> <span class="nc">LiMMBo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datainput</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">timing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments:</span>
<span class="sd">            datainput ():</span>
<span class="sd">                fdas</span>
<span class="sd">            timing (bool):</span>
<span class="sd">	        if set to True, process time will be recorded</span>
<span class="sd">            iterations (int):</span>

<span class="sd">            S (int):</span>
<span class="sd">                subsampling size `S`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes</span> <span class="o">=</span> <span class="n">datainput</span><span class="o">.</span><span class="n">phenotypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relatedness</span> <span class="o">=</span> <span class="n">datainput</span><span class="o">.</span><span class="n">relatedness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">=</span> <span class="n">timing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phenotypes</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;datainput.phenotypes cannot be converted to np.array&quot;</span><span class="p">)</span>

	<span class="k">try</span><span class="p">:</span>
	    <span class="bp">self</span><span class="o">.</span><span class="n">relatedness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relatedness</span><span class="p">)</span>
	<span class="k">except</span><span class="p">:</span>
	    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;datainput.relatedness cannot be converted to np.array&quot;</span><span class="p">)</span>
        
	<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">DataMismatch</span><span class="p">((</span><span class="s2">&quot;Subsampling size S (</span><span class="si">{}</span><span class="s2">) greater than number &quot;</span>
                <span class="s2">&quot;of phnenotypes (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<div class="viewcode-block" id="LiMMBo.runBootstrapCovarianceEstimation"><a class="viewcode-back" href="../../../vd.html#limmbo.core.vdbootstrap.LiMMBo.runBootstrapCovarianceEstimation">[docs]</a>    <span class="k">def</span> <span class="nf">runBootstrapCovarianceEstimation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">seed</span><span class="p">,</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">minCooccurrence</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Distribute variance decomposition of subset matrices via pp</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seed (int):</span>
<span class="sd">                seed to initialise random number generator for bootstrapping</span>
<span class="sd">            minCooccurrence (int):</span>
<span class="sd">                minimum number a trait pair should be sampled; once reached</span>
<span class="sd">                for all trait pairs, sampling is stopped if n is None;</span>
<span class="sd">                default=3</span>
<span class="sd">            n (int):</span>
<span class="sd">                if not None, sets the total number of permutations,</span>
<span class="sd">                otherwise n determined by minCooccurrence;  default: None</span>
<span class="sd">            cpus (int):</span>
<span class="sd">                number of cpus available for covariance estimation</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list):</span>
<span class="sd">                list containing variance components for all bootstrap runs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">__generateBootstrapMatrix</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                       <span class="n">minCooccurrence</span><span class="o">=</span><span class="n">minCooccurrence</span><span class="p">)</span>
        <span class="n">ppservers</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">cpus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">job_server</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Server</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">ppservers</span><span class="o">=</span><span class="n">ppservers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">job_server</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Server</span><span class="p">(</span><span class="n">ppservers</span><span class="o">=</span><span class="n">ppservers</span><span class="p">)</span>

        <span class="n">verboseprint</span><span class="p">(</span>
            <span class="s1">&#39;Number of CPUs available for parallelising: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">job_server</span><span class="o">.</span><span class="n">get_ncpus</span><span class="p">()),</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">):</span>
            <span class="n">pheno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bootstrapPhenotypes</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
            <span class="n">verboseprint</span><span class="p">(</span><span class="s1">&#39;Start vd for bootstrap nr </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">job_server</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__VarianceDecomposition</span><span class="p">,</span> <span class="p">(</span><span class="n">pheno</span><span class="p">,</span> <span class="n">bs</span><span class="p">),</span>
                                  <span class="p">(</span><span class="n">verboseprint</span><span class="p">,</span> <span class="p">),</span> <span class="p">(</span><span class="s2">&quot;limix.mtset&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="n">bsresult</span> <span class="o">=</span> <span class="n">job</span><span class="p">()</span>
            <span class="n">bsresult</span><span class="p">[</span><span class="s1">&#39;bootstrap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_matrix</span><span class="p">[</span><span class="n">bsresult</span><span class="p">[</span>
                <span class="s1">&#39;bsindex&#39;</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bsresult</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="LiMMBo.combineBootstrap"><a class="viewcode-back" href="../../../vd.html#limmbo.core.vdbootstrap.LiMMBo.combineBootstrap">[docs]</a>    <span class="k">def</span> <span class="nf">combineBootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine the [`S` x `S`] subset covariance matrices to find the overall</span>
<span class="sd">        [`P` x `P`] covariance matrices Cg and Cn.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            results (list):</span>
<span class="sd">		results of runBootstrapVarianceDecomposition()</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dictionary):</span>
<span class="sd">                dictionary containing:</span>

<span class="sd">                - **Cg_fit** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] genetic covariance matrix via fitting</span>
<span class="sd">                - **Cn_fit** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] noise covariance matrix via fitting</span>
<span class="sd">                - **Cg_average** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] genetic covariance matrix via simple average</span>
<span class="sd">                - **Cn_average** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] noise covariance matrix via simple average</span>
<span class="sd">                - **Cg_all_bs** (numpy.array):</span>
<span class="sd">		  [`runs` x `S` x `S`] genetic covariance matrices of `runs`</span>
<span class="sd">		  phenotype subsets of size `S`</span>
<span class="sd">                - **Cn_all_bs** (numpy.array):</span>
<span class="sd">		  [`runs` x `S` x `S`] noise covariance matrices of `runs`</span>
<span class="sd">		  phenotype subsets of size `S`</span>
<span class="sd">                - **proc_time_ind_bs** (list):</span>
<span class="sd">		  individual run times for all variance decomposition runs of</span>
<span class="sd">		  [`S` x `S`] Cg and Cn</span>
<span class="sd">                - **proc_time_sum_ind_bs** (list):</span>
<span class="sd">		  sum of individual run times for all variance decomposition</span>
<span class="sd">		  runs of [`S` x `S`] Cg and Cn</span>
<span class="sd">                - **proc_time_combine_bs** (list):</span>
<span class="sd">		  run time for finding [`P` x `P`] trait covariance estimates</span>
<span class="sd">		  from fitting [`S` x `S`] bootstrap covariance estimates</span>
<span class="sd">                - **nr_of_bs** (int):</span>
<span class="sd">		  number of bootstrap runs</span>
<span class="sd">                - **nr_of_successful_bs** (int):</span>
<span class="sd">		  total number of successful bootstrapping runs i.e. variance</span>
<span class="sd">		  decomposition converged</span>
<span class="sd">		- **results_fit_Cg** ():</span>
<span class="sd">		  results parameters of the bfgs-fit of the genetic covariance</span>
<span class="sd">		  matrices (via scipy.optimize.fmin_l_bfgs_g)</span>
<span class="sd">		- **results_fit_Cn** ():</span>
<span class="sd">		  results parameters of the bfgs-fit of the noise covariance</span>
<span class="sd">		  matrices (via scipy.optimize.fmin_l_bfgs_g)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">verboseprint</span><span class="p">(</span><span class="s1">&#39;Combine bootstrapping results...&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">bs_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getBootstrapResults</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">)</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>

        <span class="n">proc_time_combine_bs</span> <span class="o">=</span> <span class="n">time1</span> <span class="o">-</span> <span class="n">time0</span>
        <span class="n">proc_time_sum_ind_bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;process_time_bs&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Check Cg (average):&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">Cg_average</span><span class="p">,</span> <span class="n">Cg_average_ev_min</span> <span class="o">=</span> <span class="n">regularize</span><span class="p">(</span><span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;Cg_average&#39;</span><span class="p">])</span>
        <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Check Cn (average):&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">Cn_average</span><span class="p">,</span> <span class="n">Cn_average_ev_min</span> <span class="o">=</span> <span class="n">regularize</span><span class="p">(</span><span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;Cn_average&#39;</span><span class="p">])</span>
        <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Check Cg (fit):&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">Cg_fit</span><span class="p">,</span> <span class="n">Cg_fit_ev_min</span> <span class="o">=</span> <span class="n">regularize</span><span class="p">(</span><span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;Cg_fit&#39;</span><span class="p">])</span>
        <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Check Cn (fit):&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">Cn_fit</span><span class="p">,</span> <span class="n">Cn_fit_ev_min</span> <span class="o">=</span> <span class="n">regularize</span><span class="p">(</span><span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;Cn_fit&#39;</span><span class="p">])</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cg_fit&#39;</span><span class="p">:</span> <span class="n">Cg_fit</span><span class="p">,</span> <span class="s1">&#39;Cn_fit&#39;</span><span class="p">:</span> <span class="n">Cn_fit</span><span class="p">,</span>
                   <span class="s1">&#39;Cg_average&#39;</span><span class="p">:</span> <span class="n">Cg_average</span><span class="p">,</span> <span class="s1">&#39;Cn_average&#39;</span><span class="p">:</span> <span class="n">Cn_average</span><span class="p">,</span>
                   <span class="s1">&#39;Cg_all_bs&#39;</span><span class="p">:</span> <span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;Cg_bs&#39;</span><span class="p">],</span>
                   <span class="s1">&#39;Cn_all_bs&#39;</span><span class="p">:</span> <span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;Cn_bs&#39;</span><span class="p">],</span>
                   <span class="s1">&#39;proc_time_ind_bs&#39;</span><span class="p">:</span> <span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;process_time_bs&#39;</span><span class="p">],</span>
                   <span class="s1">&#39;proc_time_sum_ind_bs&#39;</span><span class="p">:</span> <span class="n">proc_time_sum_ind_bs</span><span class="p">,</span>
                   <span class="s1">&#39;proc_time_combine_bs&#39;</span><span class="p">:</span> <span class="n">proc_time_combine_bs</span><span class="p">,</span>
                   <span class="s1">&#39;nr_bs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span>
                   <span class="s1">&#39;nr_successful_bs&#39;</span><span class="p">:</span> <span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;number_of_successful_bs&#39;</span><span class="p">],</span>
                   <span class="s1">&#39;results_fit_Cg&#39;</span><span class="p">:</span> <span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;results_fit_Cg&#39;</span><span class="p">],</span>
                   <span class="s1">&#39;results_fit_Cn&#39;</span><span class="p">:</span> <span class="n">bs_results</span><span class="p">[</span><span class="s1">&#39;results_fit_Cn&#39;</span><span class="p">]</span>
                   <span class="p">}</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="LiMMBo.saveVarianceComponents"><a class="viewcode-back" href="../../../vd.html#limmbo.core.vdbootstrap.LiMMBo.saveVarianceComponents">[docs]</a>    <span class="k">def</span> <span class="nf">saveVarianceComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resultsCombineBootstrap</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
                               <span class="n">intermediate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save variance components as comma-separated files or python objects</span>
<span class="sd">        (via Cpickle).</span>

<span class="sd">        Arguments:</span>
<span class="sd">            resultsCombineBootstrap (dictionary):</span>

<span class="sd">                - **Cg_fit** (numpy.array):</span>
<span class="sd">                  [`P` x `P`] genetic covariance matrix via fitting</span>
<span class="sd">                - **Cn_fit** (numpy.array):</span>
<span class="sd">                  [`P` x `P`] noise covariance matrix via fitting</span>
<span class="sd">                - **Cg_average** (numpy.array):</span>
<span class="sd">                  [`P` x `P`] genetic covariance matrix via simple average</span>
<span class="sd">                - **Cn_average** (numpy.array):</span>
<span class="sd">                  [`P` x `P`] noise covariance matrix via simple average</span>
<span class="sd">                - **Cg_all_bs** (numpy.array):</span>
<span class="sd">                  [`runs` x `S` x `S`] genetic covariance matrices of `runs`</span>
<span class="sd">                  phenotype subsets of size `S`</span>
<span class="sd">                - **Cn_all_bs** (numpy.array):</span>
<span class="sd">                  [`runs` x `S` x `S`] noise covariance matrices of `runs`</span>
<span class="sd">                  phenotype subsets of size `S`</span>
<span class="sd">                - **proc_time_ind_bs** (list):</span>
<span class="sd">                  individual run times for all variance decomposition runs of</span>
<span class="sd">                  [`S` x `S`] Cg and Cn</span>
<span class="sd">                - **proc_time_sum_ind_bs** (list):</span>
<span class="sd">                  sum of individual run times for all variance decomposition</span>
<span class="sd">                  runs of [`S` x `S`] Cg and Cn</span>
<span class="sd">                - **proc_time_combine_bs** (list):</span>
<span class="sd">                  run time for finding [`P` x `P`] trait covariance estimates</span>
<span class="sd">                  from fitting [`S` x `S`] bootstrap covariance estimates</span>
<span class="sd">                - **nr_of_bs** (int):</span>
<span class="sd">                  number of bootstrap runs</span>
<span class="sd">                - **nr_of_successful_bs** (int):</span>
<span class="sd">                  total number of successful bootstrapping runs i.e. variance</span>
<span class="sd">                  decomposition converged</span>
<span class="sd">                - **results_fit_Cg** ():</span>
<span class="sd">                  results parameters of the bfgs-fit of the genetic covariance</span>
<span class="sd">                  matrices (via scipy.optimize.fmin_l_bfgs_g)</span>
<span class="sd">                - **results_fit_Cn** ():</span>
<span class="sd">                  results parameters of the bfgs-fit of the noise covariance</span>
<span class="sd">                  matrices (via scipy.optimize.fmin_l_bfgs_g)</span>

<span class="sd">            output (string):</span>
<span class="sd">                path/to/directory where variance components will be saved;</span>
<span class="sd">                needs writing permission</span>
<span class="sd">            intermediate (bool):</span>
<span class="sd">                if set to True, intermediate variance components (average</span>
<span class="sd">                covariance matrices, bootstrap matrices and results parameter</span>
<span class="sd">                of BFGS fit) are saved</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Generate output files&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Write [`P` x `P`] covariance matrices&quot;</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;Cg_fit&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/Cg_fit_seed</span><span class="si">{}</span><span class="s1">.csv&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;Cn_fit&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/Cn_fit_seed</span><span class="si">{}</span><span class="s1">.csv&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">intermediate</span><span class="p">:</span>
            <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Write bootstrap matrix&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/bootstrap_matrix.csv&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Save intermediate variance components&quot;</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">verboseprint</span><span class="p">((</span><span class="s2">&quot;Write covariance matrices based on average of &quot;</span>
                <span class="s2">&quot;bootstrap matrices&quot;</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;Cg_average&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/Cg_average_seed</span><span class="si">%s</span><span class="s2">.csv&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">),</span>
                <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;Cn_average&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/Cn_average_seed</span><span class="si">%s</span><span class="s2">.csv&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">),</span>
                <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">verboseprint</span><span class="p">((</span><span class="s2">&quot;Pickle array of all [`S` x `S`] bootstrap &quot;</span>
                    <span class="s2">&quot;covariance matrices&quot;</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;Cg_all_bs&#39;</span><span class="p">],</span>
                     <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/Cg_all_bootstraps.p&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;Cn_all_bs&#39;</span><span class="p">],</span>
                     <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/Cn_all_bootstraps.p&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>

            <span class="n">verboseprint</span><span class="p">((</span><span class="s2">&quot;Pickle result parameters of BFGS fit for fitting &quot;</span>
                <span class="s2">&quot;the [`S` x `S`] bootstrap covariance matrices to the &quot;</span>
                <span class="s2">&quot;[`P` x `P`] overall trait covariance matrices&quot;</span><span class="p">),</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;results_fit_Cg&#39;</span><span class="p">],</span>
                         <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/optimise_results_Cg.p&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;results_fit_Cg&#39;</span><span class="p">],</span>
                         <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/optimise_results_Cn.p&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">:</span>
            <span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Save process times&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;proc_time_ind_bs&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/process_time_all_bootstraps.csv&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output</span><span class="p">),</span>
                <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">overall_time</span> <span class="o">=</span>  <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">[</span><span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;proc_time_combine_bs&#39;</span><span class="p">],</span>
                 <span class="n">resultsCombineBootstrap</span><span class="p">[</span><span class="s1">&#39;proc_time_sum_ind_bs&#39;</span><span class="p">]],</span>
                <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Proctime combine BS&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Proctime sum of individual BS&quot;</span><span class="p">])</span>
            <span class="n">overall_time</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/process_time_summary.csv&quot;</span> <span class="o">%</span> <span class="n">output</span><span class="p">,</span>
                <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__generateBootstrapMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">12321</span><span class="p">,</span> <span class="n">minCooccurrence</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate subsampling matrix.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seed (int, optional):</span>
<span class="sd">                for pseudo-random numbers generation; default: 12321</span>
<span class="sd">            minCooccurrence (int):</span>
<span class="sd">                minimum number a trait pair should be sampled; once reached</span>
<span class="sd">                for all trait pairs, sampling is stopped if n is None;</span>
<span class="sd">                default=3</span>
<span class="sd">            n (int):</span>
<span class="sd">                if not None, sets the total number of permutations,</span>
<span class="sd">                otherwise n determined by minCooccurrence;  default: None</span>

<span class="sd">        Returns:</span>
<span class="sd">            None:</span>
<span class="sd">                updates LiMMBo instance with:</span>

<span class="sd">             - **seed** (int):</span>
<span class="sd">               seed for pseudo-random numbers generation</span>
<span class="sd">             - **runs** (int):</span>
<span class="sd">		n, if n was not None, or determined once all trait-trait</span>
<span class="sd">		subsamplings have occurrd minCooccurence times</span>
<span class="sd">             - **counts_min** (int):</span>
<span class="sd">	       minimum trait-trait co-occurrence in sampling matrix</span>
<span class="sd">             - **bootstrap_matrix** (numpy.array):</span>
<span class="sd">		[`runs` x `S`] matrix containing bootstrap samples of numbers</span>
<span class="sd">		range(`P`)</span>

<span class="sd">        Examples:</span>

<span class="sd">             .. doctest::</span>

<span class="sd">                &gt;&gt;&gt; from limmbo.io import input</span>
<span class="sd">                &gt;&gt;&gt; from limmbo.core import vdbootstrap</span>
<span class="sd">                &gt;&gt;&gt; import numpy as np</span>
<span class="sd">                &gt;&gt;&gt; from numpy.random import RandomState</span>
<span class="sd">                &gt;&gt;&gt; from numpy.linalg import cholesky as chol</span>
<span class="sd">                &gt;&gt;&gt; random = RandomState(5)</span>
<span class="sd">                &gt;&gt;&gt; P = 10</span>
<span class="sd">                &gt;&gt;&gt; N = 1000</span>
<span class="sd">                &gt;&gt;&gt; SNP = 1000</span>
<span class="sd">                &gt;&gt;&gt; pheno = random.normal(0,1, (N, P))</span>
<span class="sd">                &gt;&gt;&gt; pheno_samples = np.array(</span>
<span class="sd">                ...     [&#39;S{}&#39;.format(x+4) for x in range(N)])</span>
<span class="sd">                &gt;&gt;&gt; phenotype_ID = np.array(</span>
<span class="sd">                ...     [&#39;ID{}&#39;.format(x+1) for x in range(P)])</span>
<span class="sd">                &gt;&gt;&gt; X = (random.rand(N, SNP) &lt; 0.3).astype(float)</span>
<span class="sd">                &gt;&gt;&gt; relatedness = np.dot(X, X.T)/float(SNP)</span>
<span class="sd">                &gt;&gt;&gt; relatedness_samples = np.array(</span>
<span class="sd">                ...     [&#39;S{}&#39;.format(x+1) for x in range(N)])</span>
<span class="sd">                &gt;&gt;&gt; indata = input.InputData()</span>
<span class="sd">                &gt;&gt;&gt; indata.addPhenotypes(phenotypes = pheno,</span>
<span class="sd">                ...                      pheno_samples = pheno_samples,</span>
<span class="sd">                ...                      phenotype_ID = phenotype_ID)</span>
<span class="sd">                &gt;&gt;&gt; indata.addRelatedness(relatedness = relatedness,</span>
<span class="sd">                ...                  relatedness_samples = relatedness_samples)</span>
<span class="sd">		&gt;&gt;&gt; limmbo = vdbootstrap.LiMMBo(datainput=indata, verbose=False)</span>
<span class="sd">		&gt;&gt;&gt; limmbo.generateBootstrapMatrix(seed=12,</span>
<span class="sd">                ...               		   minCooccurrence=3)</span>
<span class="sd">		&gt;&gt;&gt; limmbo.bootstrap_matrix[:5,:]</span>
<span class="sd">		array([[5, 8, 7, 0, 4],</span>
<span class="sd">		       [6, 0, 9, 7, 3],</span>
<span class="sd">		       [7, 0, 6, 3, 1],</span>
<span class="sd">		       [8, 4, 9, 7, 5],</span>
<span class="sd">		       [2, 4, 7, 1, 5]])</span>
<span class="sd">		&gt;&gt;&gt; limmbo.runs</span>
<span class="sd">		30</span>
<span class="sd">		&gt;&gt;&gt; limmbo.count</span>
<span class="sd">		3</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rand_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">))</span>
        <span class="n">return_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">verboseprint</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;Generate bootstrap matrix with </span><span class="si">{}</span><span class="s1"> bootstrap samples &#39;</span>
                 <span class="s1">&#39;(number of specified bootstraps&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">bootstrap</span> <span class="o">=</span> <span class="n">rand_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span>
                    <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">))</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runs</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">counts</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">minCooccurrence</span><span class="p">:</span>
                <span class="n">bootstrap</span> <span class="o">=</span> <span class="n">rand_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span>
                    <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">))</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_list</span><span class="p">)</span>
            <span class="n">verboseprint</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;Generated bootstrap matrix with </span><span class="si">{}</span><span class="s1"> bootstrap runs &#39;</span>
                <span class="s1">&#39;such that each trait-trait combination was &#39;</span>
		<span class="s1">&#39;sampled </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span> <span class="n">minCooccurrence</span><span class="p">),</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">return_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__bootstrapPhenotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subsample [`S`] phenotypes with [`N`] samples form total of [`P`]</span>
<span class="sd">        phenotypes. Indices for subsampling provided in [`bs` x `S`]</span>
<span class="sd">        LiMMBo.bootstrap_matrix, where `bs` is the total number of bootstraps</span>

<span class="sd">        Arguments:</span>
<span class="sd">            bs (int):</span>
<span class="sd">                bootstrap index</span>

<span class="sd">        Uses:</span>
<span class="sd">            self.bootstrap_matrix (array-like):</span>
<span class="sd">                [`bs` x `S`] with subsampling indeces for phenotypes</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.array):</span>

<span class="sd">                - **phenotypes**:</span>
<span class="sd">		  [`N` x `S`] of subsampled phenotypes</span>

<span class="sd">        Examples:</span>

<span class="sd">             .. doctest::</span>

<span class="sd">		 &gt;&gt;&gt; import pandas</span>
<span class="sd">		 &gt;&gt;&gt; import numpy</span>
<span class="sd">		 &gt;&gt;&gt; from numpy.random import RandomState</span>
<span class="sd">		 &gt;&gt;&gt; from limmbo.io.input import InputData</span>
<span class="sd">		 &gt;&gt;&gt; from limmbo.core.vdbootstrap import LiMMBo</span>
<span class="sd">		 &gt;&gt;&gt; from numpy.linalg import cholesky as chol</span>
<span class="sd">		 &gt;&gt;&gt; random = RandomState(10)</span>
<span class="sd">		 &gt;&gt;&gt; P = 10</span>
<span class="sd">		 &gt;&gt;&gt; S = 5</span>
<span class="sd">		 &gt;&gt;&gt; N = 100</span>
<span class="sd">		 &gt;&gt;&gt; S = 1000</span>
<span class="sd">		 &gt;&gt;&gt; snps = (random.rand(N, S) &lt; 0.2).astype(float)</span>
<span class="sd">		 &gt;&gt;&gt; kinship = numpy.dot(snps, snps.T)/float(10)</span>
<span class="sd">		 &gt;&gt;&gt; y  = random.randn(N,P)</span>
<span class="sd">		 &gt;&gt;&gt; pheno = numpy.dot(chol(kinship),y)</span>
<span class="sd">		 &gt;&gt;&gt; pheno_ID = [&#39;PID{}&#39;.format(x+1) for x in range(P)]</span>
<span class="sd">		 &gt;&gt;&gt; samples = [&#39;SID{}&#39;.format(x+1) for x in range(N)]</span>
<span class="sd">		 &gt;&gt;&gt; datainput = InputData()</span>
<span class="sd">		 &gt;&gt;&gt; datainput.addPhenotypes(phenotypes = pheno,</span>
<span class="sd">		 ...                         phenotype_ID = pheno_ID,</span>
<span class="sd">		 ...                         pheno_samples = samples)</span>
<span class="sd">		 &gt;&gt;&gt; datainput.addRelatedness(relatedness = kinship,</span>
<span class="sd">		 ...                          relatedness_samples = samples)</span>
<span class="sd">		 &gt;&gt;&gt; limmbo = LiMMBo(datainput = datainput, verbose=False)</span>
<span class="sd">		 &gt;&gt;&gt; limmbo.generateBootstrapMatrix(P = P, S = S)</span>
<span class="sd">		 &gt;&gt;&gt; bootstrap_pheno_1 = limmbo.bootstrapPhenotypes(bs = 0)</span>
<span class="sd">		 &gt;&gt;&gt; bootstrap_pheno_1.shape</span>
<span class="sd">		 (100, 5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bootstrap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_matrix</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">phenotypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phenotypes</span><span class="p">[:,</span> <span class="n">bootstrap</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">phenotypes</span>


    <span class="k">def</span> <span class="nf">__getBootstrapResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect bootstrap results of [`S` x `S`] traits and combine all runs to</span>
<span class="sd">        total [`P` x `P`] covariance matrix</span>

<span class="sd">        Arguments:</span>
<span class="sd">            results (list):</span>
<span class="sd">                results of runBootstrapVarianceDecomposition()</span>

<span class="sd">        Uses:</span>
<span class="sd">            runs (int):</span>
<span class="sd">                number of bootstrapping runs executed for this experiment</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dictionary):</span>
<span class="sd">                dictionary containing:</span>

<span class="sd">                - **Cg_fit** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] genetic covariance matrix via fitting</span>
<span class="sd">                - **Cn_fit** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] noise covariance matrix via fitting</span>
<span class="sd">                - **Cg_average** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] genetic covariance matrix via simple average</span>
<span class="sd">                - **Cn_average** (numpy.array):</span>
<span class="sd">		  [`P` x `P`] noise covariance matrix via simple average</span>
<span class="sd">                - **Cg_bs** (numpy.array):</span>
<span class="sd">		  [`runs` x `S` x `S`] genetic covariance matrices of `runs`</span>
<span class="sd">		  phenotype subsets of size `S`</span>
<span class="sd">                - **Cn_bs** (numpy.array):</span>
<span class="sd">		  [`runs` x `S` x `S`] noise covariance matrices of `runs`</span>
<span class="sd">		  phenotype subsets of size `S`</span>
<span class="sd">                - **process_time_bs** (list):</span>
<span class="sd">		  run times for all variance decomposition runs of [`S` x `S`]</span>
<span class="sd">		  Cg and Cn</span>
<span class="sd">                - **number_of_successful_bs** (int):</span>
<span class="sd">		  total number of successful bootstrapping runs i.e. variance</span>
<span class="sd">		  decomposition converged</span>
<span class="sd">		- **results_fit_Cg** ():</span>
<span class="sd">		  results parameters of the bfgs-fit of the genetic covariance</span>
<span class="sd">		  matrices (via scipy.optimize.fmin_l_bfgs_g)</span>
<span class="sd">		- **results_fit_Cn** ():</span>
<span class="sd">		  results parameters of the bfgs-fit of the noise covariance</span>
<span class="sd">		  matrices (via scipy.optimize.fmin_l_bfgs_g)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># list to contain trait indices of each bootstrap run</span>
        <span class="n">bootstrap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#sample_ID = None</span>

        <span class="c1"># create np.arrays of dimension PxP for mean and std of each entry in</span>
        <span class="c1"># covariance matrix</span>
        <span class="n">Cg_average</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">))</span>
        <span class="n">Cn_average</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">))</span>

        <span class="c1"># Process time per bootstrap</span>
        <span class="n">process_time_bs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># create np.arrays of dimension runs x P x P to store the bootstrapping</span>
        <span class="c1"># results for averaging</span>
        <span class="n">Cg_bs_large</span> <span class="o">=</span> <span class="n">nans</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">))</span>
        <span class="n">Cn_bs_large</span> <span class="o">=</span> <span class="n">nans</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">))</span>

        <span class="n">Cg_bs</span> <span class="o">=</span> <span class="n">nans</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">))</span>
        <span class="n">Cn_bs</span> <span class="o">=</span> <span class="n">nans</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">vdresult</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">bootstrap</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;bootstrap&#39;</span><span class="p">]</span>
            <span class="n">process_time_bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;process_time&#39;</span><span class="p">])</span>

            <span class="c1"># store results of each bootstrap as matrix of inflated</span>
            <span class="c1"># matrices: NAs for traits that were not sampled</span>
            <span class="k">if</span> <span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;Cg&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;Cn&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">Cg_bs_large</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">inflate_matrix</span><span class="p">(</span>
                <span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;Cg&#39;</span><span class="p">],</span> <span class="n">bootstrap</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">P</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">Cn_bs_large</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">inflate_matrix</span><span class="p">(</span>
                <span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;Cn&#39;</span><span class="p">],</span> <span class="n">bootstrap</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">P</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># store results of each bootstrap as matrix of small S x S</span>
            <span class="c1"># matrices generated by each bootstrap</span>
            <span class="n">Cg_bs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;Cg&#39;</span><span class="p">]</span>
            <span class="n">Cn_bs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vdresult</span><span class="p">[</span><span class="s1">&#39;Cn&#39;</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Total number of successful bootstrapping runs</span>
        <span class="n">number_of_bs</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Computing mean of bootstrapping results at</span>
        <span class="c1"># each position p1, p2 in overall PxP covariance matrix</span>
        <span class="n">verboseprint</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;Computing mean of bootstrapping results&quot;</span><span class="p">),</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">Cg_bs_large</span><span class="p">[:,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
                <span class="n">Cg_average</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">sp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vals</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">Cn_bs_large</span><span class="p">[:,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
                <span class="n">Cn_average</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">sp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vals</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="n">Cg_reg</span><span class="p">,</span> <span class="n">ev_g</span> <span class="o">=</span> <span class="n">regularize</span><span class="p">(</span><span class="n">Cg_average</span><span class="p">)</span>
        <span class="n">Cn_reg</span><span class="p">,</span> <span class="n">ev_n</span><span class="p">,</span>  <span class="o">=</span> <span class="n">regularize</span><span class="p">(</span><span class="n">Cn_average</span><span class="p">)</span>

        <span class="n">verboseprint</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;Fitting bootstrapping results: minimize residual sum of &quot;</span>
             <span class="s2">&quot;squares over all bootstraps&quot;</span><span class="p">),</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">Cg_fit</span><span class="p">,</span> <span class="n">results_fit_Cg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fit_bootstrap_results</span><span class="p">(</span>
            <span class="n">cov_init</span><span class="o">=</span><span class="n">Cg_reg</span><span class="p">,</span>
            <span class="n">cov_bootstrap</span><span class="o">=</span><span class="n">Cg_bs</span><span class="p">,</span>
            <span class="n">bootstrap_indeces</span><span class="o">=</span><span class="n">bootstrap</span><span class="p">,</span>
            <span class="n">number_of_bs</span><span class="o">=</span><span class="n">number_of_bs</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cg&quot;</span><span class="p">)</span>
        <span class="n">Cn_fit</span><span class="p">,</span> <span class="n">results_fit_Cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fit_bootstrap_results</span><span class="p">(</span>
            <span class="n">cov_init</span><span class="o">=</span><span class="n">Cn_reg</span><span class="p">,</span>
            <span class="n">cov_bootstrap</span><span class="o">=</span><span class="n">Cn_bs</span><span class="p">,</span>
            <span class="n">bootstrap_indeces</span><span class="o">=</span><span class="n">bootstrap</span><span class="p">,</span>
            <span class="n">number_of_bs</span><span class="o">=</span><span class="n">number_of_bs</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cn&quot;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cg_bs&#39;</span><span class="p">:</span> <span class="n">Cg_bs</span><span class="p">,</span> <span class="s1">&#39;Cn_bs&#39;</span><span class="p">:</span> <span class="n">Cn_bs</span><span class="p">,</span>
                   <span class="s1">&#39;Cg_fit&#39;</span><span class="p">:</span> <span class="n">Cg_fit</span><span class="p">,</span> <span class="s1">&#39;Cn_fit&#39;</span><span class="p">:</span> <span class="n">Cn_fit</span><span class="p">,</span>
                   <span class="s1">&#39;Cg_average&#39;</span><span class="p">:</span> <span class="n">Cg_average</span><span class="p">,</span> <span class="s1">&#39;Cn_average&#39;</span><span class="p">:</span> <span class="n">Cn_average</span><span class="p">,</span>
                   <span class="s1">&#39;process_time_bs&#39;</span><span class="p">:</span> <span class="n">process_time_bs</span><span class="p">,</span>
                   <span class="s1">&#39;number_of_successful_bs&#39;</span><span class="p">:</span> <span class="n">number_of_bs</span><span class="p">,</span>
                   <span class="s1">&#39;results_fit_Cg&#39;</span><span class="p">:</span> <span class="n">results_fit_Cg</span><span class="p">,</span>
                   <span class="s1">&#39;results_fit_Cn&#39;</span><span class="p">:</span> <span class="n">results_fit_Cn</span><span class="p">,</span>
                   <span class="p">}</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">__fit_bootstrap_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_init</span><span class="p">,</span> <span class="n">cov_bootstrap</span><span class="p">,</span>
                                <span class="n">bootstrap_indeces</span><span class="p">,</span> <span class="n">number_of_bs</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit  bootstrap results of [`S` x `S`] traits and combine all runs to</span>
<span class="sd">	total [`P` x `P`] covariance matrix.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            cov_init (array-like):</span>
<span class="sd">		[`P` x `P`] covariance matrix used to initialise fitting</span>
<span class="sd">            number_of_bs (int):</span>
<span class="sd">		number of successful bootstrapping runs executed for this</span>
<span class="sd">		experiment</span>
<span class="sd">            cov_bootstrap (array-like):</span>
<span class="sd">		[`number_of_bs` x `S` x `S`] bootstrap results</span>
<span class="sd">            bootstrap_indeces (array-like):</span>
<span class="sd">		[`number_of_bs` x `S`] matrix of bootstrapping indeces</span>
<span class="sd">            name (string):</span>
<span class="sd">		name of covariance matrix</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">		tuple containing:</span>

<span class="sd">                - **C_opt_value** (array-like):</span>
<span class="sd">                  [`P` x `P`] covariance matrix if fit successful, else 1x1</span>
<span class="sd">		  matrix containing string &#39;did not converge&#39;</span>
<span class="sd">		- **results_fit** ():</span>
<span class="sd">		  results parameters of the bfgs-fit of the covariance</span>
<span class="sd">		  matrix (via scipy.optimize.fmin_l_bfgs_g)</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialise free-from Covariance Matrix: use simple average of</span>
        <span class="c1"># bootstraps as initial values</span>
        <span class="c1"># make use of Choleski decomposition and get parameters associated with</span>
        <span class="c1"># cov_init</span>
        <span class="c1">#C_init = dlimix.CFreeFormCF(self.P)</span>
        <span class="c1">#C_init.setParamsCovariance(cov_init)</span>
        <span class="n">C_init</span> <span class="o">=</span> <span class="n">FreeFormCov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
        <span class="n">C_init</span><span class="o">.</span><span class="n">setCovariance</span><span class="p">(</span><span class="n">cov_init</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">C_init</span><span class="o">.</span><span class="n">getParams</span><span class="p">()</span>

        <span class="c1"># initialise free-form covariance matrix C_fit: parameters to be set in</span>
        <span class="c1"># optimize function</span>
        <span class="c1">#C_fit = dlimix.CFreeFormCF(self.P)</span>
        <span class="n">C_fit</span> <span class="o">=</span> <span class="n">FreeFormCov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>

        <span class="c1"># Fit bootstrap results to obtain closest covariance matrix</span>
        <span class="c1"># use parameters obtained from mean-initiated covariance matrix above</span>
        <span class="n">verboseprint</span><span class="p">(</span>
            <span class="s2">&quot;Fitting parameters (minimizing rss via BFGS)...&quot;</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">results_fit</span> <span class="o">=</span> <span class="n">opt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__rss</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">C_fit</span><span class="p">,</span> <span class="n">number_of_bs</span><span class="p">,</span> <span class="n">bootstrap_indeces</span><span class="p">,</span> <span class="n">cov_bootstrap</span><span class="p">),</span>
            <span class="n">factr</span><span class="o">=</span><span class="mf">1e12</span><span class="p">,</span>
            <span class="n">iprint</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">results_fit</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;warnflag&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#C_opt = dlimix.CFreeFormCF(self.P)</span>
            <span class="n">C_opt</span> <span class="o">=</span> <span class="n">FreeFormCov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
            <span class="n">C_opt</span><span class="o">.</span><span class="n">setParams</span><span class="p">(</span><span class="n">results_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">C_opt_value</span> <span class="o">=</span> <span class="n">C_opt</span><span class="o">.</span><span class="n">K</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C_opt_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;did not converge&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">C_opt_value</span><span class="p">,</span> <span class="n">results_fit</span>

    <span class="k">def</span> <span class="nf">__rss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">n_bootstrap</span><span class="p">,</span> <span class="n">index_bootstrap</span><span class="p">,</span> <span class="n">list_C</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute residual sum of squares and gradient for estimate of covariance</span>
<span class="sd">        matrix C and bootstrapped values of C.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            params (array-like):</span>
<span class="sd">		of parameters used for initialising estimate C</span>
<span class="sd">		(length: 1/2*`P`*(`P`+1))</span>
<span class="sd">            C:</span>
<span class="sd">		intialised free-form covariance matrix, to be fitted</span>
<span class="sd">            n_bootstrap (int):</span>
<span class="sd">		number of successful bootstrapping runs executed for this</span>
<span class="sd">		experiment</span>
<span class="sd">            index_bootstrap (numpy.array):</span>
<span class="sd">		[`number_of_bs` x `S`] matrix of bootstrapping indeces</span>
<span class="sd">            list_C (list):</span>
<span class="sd">		list of n_bootstrap [`S` x `S`] bootstrapped covariance</span>
<span class="sd">		matrices</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">                tuple containing:</span>

<span class="sd">                - **RSS_res**:</span>
<span class="sd">		  residual sum of squares</span>
<span class="sd">                - **RSS_grad_res**:</span>
<span class="sd">		  gradient of residual sum of squares function</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialise values of covariance matrix with parameters (based on</span>
        <span class="c1"># cholesky decomposition)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">C</span><span class="o">.</span><span class="n">setParams</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># get values of the covariance matrix</span>
        <span class="n">C_value</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">K</span><span class="p">()</span>
        <span class="c1"># number of parameters: 1/2*P*(P+1)</span>
        <span class="n">n_params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># compute residual sum of squares between estimate of P x P Cg and</span>
        <span class="c1"># bootstrapped S x S Cgs</span>
        <span class="n">RSS_res</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__RSS_compute</span><span class="p">(</span><span class="n">n_bootstrap</span><span class="p">,</span> <span class="n">C_value</span><span class="p">,</span> <span class="n">list_C</span><span class="p">,</span>
                                          <span class="n">index_bootstrap</span><span class="p">)</span>
        <span class="c1"># compute gradient (first derivative of rss at each bootstrap)</span>
        <span class="n">RSS_grad_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__RSS_grad_compute</span><span class="p">(</span><span class="n">n_bootstrap</span><span class="p">,</span> <span class="n">n_params</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
                                                <span class="n">C_value</span><span class="p">,</span> <span class="n">list_C</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">RSS_res</span><span class="p">,</span> <span class="n">RSS_grad_res</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__RSS_compute</span><span class="p">(</span><span class="n">n_bootstrap</span><span class="p">,</span> <span class="n">C_value</span><span class="p">,</span> <span class="n">list_C</span><span class="p">,</span> <span class="n">index_bootstrap</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute residual sum of squares (rss) for each bootstrap run</span>

<span class="sd">        - used parameter to be optimized in quasi-Newton method (BFGS) of</span>
<span class="sd">          optimization</span>
<span class="sd">        - bootstrap matrices versus matrix to be optimized</span>
<span class="sd">        - matrix to be optimized initialised with average over all bootstraps</span>
<span class="sd">          for each position</span>

<span class="sd">        Arguments:</span>
<span class="sd">            n_bootstrap (int):</span>
<span class="sd">                number of successful bootstrap runs;</span>
<span class="sd">            C_value (array-like):</span>
<span class="sd">                [`P` x `P`] matrix to be optimized</span>
<span class="sd">            list_C (array-like):</span>
<span class="sd">                [`n_bootstrap` x `S` x `S`]  bootstrapped covariance matrices</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">                tuple containing:</span>

<span class="sd">                - **res** (double):</span>
<span class="sd">		  sum of residual sum of squares over all `n_bootstrap` runs</span>
<span class="sd">                - **index** (list) :</span>
<span class="sd">		  [`n_bootstrap` x `S`] list containing trait indeces used in</span>
<span class="sd">		  each bootstrap run; to be passed to gradient computation</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bootstrap</span><span class="p">):</span>
            <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">index_bootstrap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">index_bootstrap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">bn</span><span class="o">.</span><span class="n">ss</span><span class="p">(</span><span class="n">C_value</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">list_C</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">index</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__RSS_grad_compute</span><span class="p">(</span><span class="n">n_bootstrap</span><span class="p">,</span> <span class="n">n_params</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C_value</span><span class="p">,</span> <span class="n">list_C</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute gradient of residual sum of squares (rss) for each bootstrap</span>
<span class="sd">        run at each index</span>

<span class="sd">        - used as gradient parameter in quasi-Newton method (BFGS) of</span>
<span class="sd">          optimization</span>
<span class="sd">        - matrix to be optimized initialised with average over all bootstraps</span>
<span class="sd">          for each position</span>

<span class="sd">        Arguments:</span>
<span class="sd">            n_bootstrap (int):</span>
<span class="sd">                number of successful bootstrap runs;</span>
<span class="sd">            n_params (int):</span>
<span class="sd">                number of parameters of the model (parameters needed to build</span>
<span class="sd">                positive, semi-definite matrix with Choleski decomposition)</span>
<span class="sd">            C_value (array-like):</span>
<span class="sd">                [`P` x `P`] matrix to be optimized</span>
<span class="sd">            list_C (array-like):</span>
<span class="sd">                [`n_bootstrap` x `S` x `S`]  bootstrapped covariance matrices</span>
<span class="sd">            index (list):</span>
<span class="sd">                [`n_bootstrap `x `S`] trait indices used in each bootstrap run</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.array):</span>

<span class="sd">                - **res**:</span>
<span class="sd">		  [`n_params` x 1] sum of gradient over all successful bootstrap</span>
<span class="sd">                  runs for each parameter to be fitted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_params</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_params</span><span class="p">):</span>
            <span class="c1">#Cgrad = C.Kgrad_param(pi)</span>
            <span class="n">Cgrad</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">K_grad_i</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bootstrap</span><span class="p">):</span>
                <span class="n">res</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Cgrad</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">C_value</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">list_C</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">__VarianceDecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phenoSubset</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Compute variance decomposition of phenotypes into genetic and noise</span>
<span class="sd">        covariance</span>

<span class="sd">        Arguments:</span>
<span class="sd">            phenoSubset (array-like):</span>
<span class="sd">                [`N` x `S`] phenotypes for which variance decomposition should</span>
<span class="sd">		be computed</span>
<span class="sd">            bs (int):</span>
<span class="sd">                number of subsample</span>
<span class="sd">            phenotypes (array-like):</span>
<span class="sd">                [`N` x `P`] original phenotypes</span>
<span class="sd">            relatedness (array-like):</span>
<span class="sd">                [`N` x `N`] kinship/genetic relatedness used in estimation of</span>
<span class="sd">                genetic component</span>
<span class="sd">            output (string):</span>
<span class="sd">                output directory; needed for caching</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dictionary):</span>
<span class="sd">                dictionary containing:</span>

<span class="sd">                - **Cg** (numpy.array):</span>
<span class="sd">		  [`S` x `S`] genetic variance component</span>
<span class="sd">                - **Cn** (numpy.array):</span>
<span class="sd">		  [`S` x `S`] noise variance component</span>
<span class="sd">                - **process_time** (double):</span>
<span class="sd">		  cpu time of variance decomposition</span>
<span class="sd">                - **bsindex** (int):</span>
<span class="sd">		  number of subsample</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time variance decomposition</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">vd</span> <span class="o">=</span> <span class="n">limix</span><span class="o">.</span><span class="n">mtset</span><span class="o">.</span><span class="n">MTSet</span><span class="p">(</span><span class="n">Y</span><span class="o">=</span><span class="n">phenoSubset</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">relatedness</span><span class="p">)</span>
        <span class="n">vd_null_info</span> <span class="o">=</span> <span class="n">vd</span><span class="o">.</span><span class="n">fitNull</span><span class="p">(</span>
            <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">n_times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">,</span>
            <span class="n">rewrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">processtime</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>

        <span class="k">if</span> <span class="n">vd_null_info</span><span class="p">[</span><span class="s1">&#39;conv&#39;</span><span class="p">]:</span>
            <span class="n">verboseprint</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;Variance decomposition for bootstrap number </span><span class="si">{}</span><span class="s1"> &#39;</span>
                <span class="s1">&#39;converged&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">Cg</span> <span class="o">=</span> <span class="n">vd_null_info</span><span class="p">[</span><span class="s1">&#39;Cg&#39;</span><span class="p">]</span>
            <span class="n">Cn</span> <span class="o">=</span> <span class="n">vd_null_info</span><span class="p">[</span><span class="s1">&#39;Cn&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verboseprint</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;Variance decomposition for bootstrap number </span><span class="si">{}</span><span class="s1"> &#39;</span>
                <span class="s1">&#39;did not converge&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">Cg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Cn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;Cg&#39;</span><span class="p">:</span> <span class="n">Cg</span><span class="p">,</span> <span class="s1">&#39;Cn&#39;</span><span class="p">:</span> <span class="n">Cn</span><span class="p">,</span> <span class="s1">&#39;process_time&#39;</span><span class="p">:</span> <span class="n">processtime</span><span class="p">,</span> <span class="s1">&#39;bsindex&#39;</span><span class="p">:</span> <span class="n">bs</span><span class="p">}</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Hannah V. Meyer.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'b',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>